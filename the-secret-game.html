<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Secret Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --fire: #ff4500;
            --fire-glow: #ff6a00;
            --protected: #00bfff;
            --protected-glow: #00e5ff;
            --bg-dark: #0a0a1a;
            --bg-card: #12122a;
            --text: #e0e0ff;
            --accent: #7c4dff;
        }

        body {
            background: var(--bg-dark);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .stars {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle var(--dur) ease-in-out infinite alternate;
        }

        @keyframes twinkle {
            from { opacity: 0.2; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1.2); }
        }

        #app {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            font-family: 'Orbitron', monospace;
            text-align: center;
            font-size: 2.2em;
            background: linear-gradient(135deg, var(--fire), var(--fire-glow), #ffcc00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            text-shadow: 0 0 40px rgba(255,69,0,0.3);
        }

        .subtitle {
            text-align: center;
            color: #8888bb;
            font-size: 0.95em;
            margin-bottom: 30px;
        }

        .mode-selector {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 14px 28px;
            border: 2px solid #333;
            border-radius: 14px;
            background: var(--bg-card);
            color: var(--text);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .mode-btn:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(124,77,255,0.3);
        }

        .mode-btn.active {
            border-color: var(--fire);
            background: linear-gradient(135deg, rgba(255,69,0,0.15), rgba(255,106,0,0.1));
            box-shadow: 0 0 30px rgba(255,69,0,0.2);
        }

        .mode-btn .label {
            display: block;
            font-size: 0.75em;
            color: #8888bb;
            margin-top: 4px;
            font-weight: 300;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            align-items: start;
        }

        @media (max-width: 900px) {
            .game-container {
                grid-template-columns: 1fr;
            }
        }

        .grid-wrapper {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 16px;
            border: 1px solid #222244;
            position: relative;
            overflow: hidden;
        }

        .grid-wrapper::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at var(--mx, 50%) var(--my, 50%), rgba(255,69,0,0.03) 0%, transparent 50%);
            pointer-events: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            image-rendering: pixelated;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .info-card {
            background: var(--bg-card);
            border: 1px solid #222244;
            border-radius: 14px;
            padding: 18px;
        }

        .info-card h3 {
            font-family: 'Orbitron', monospace;
            font-size: 0.85em;
            color: var(--accent);
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #1a1a3a;
        }

        .stat:last-child { border-bottom: none; }

        .stat-label {
            color: #8888bb;
            font-size: 0.9em;
        }

        .stat-value {
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            font-size: 0.95em;
        }

        .stat-value.fire { color: var(--fire); }
        .stat-value.shield { color: var(--protected); }
        .stat-value.day { color: #ffcc00; }

        .phase-indicator {
            text-align: center;
            padding: 14px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.1em;
            font-family: 'Orbitron', monospace;
            transition: all 0.5s ease;
            letter-spacing: 1px;
        }

        .phase-day {
            background: linear-gradient(135deg, rgba(255,204,0,0.15), rgba(255,170,0,0.1));
            border: 1px solid rgba(255,204,0,0.3);
            color: #ffcc00;
        }

        .phase-night {
            background: linear-gradient(135deg, rgba(255,69,0,0.15), rgba(200,0,0,0.1));
            border: 1px solid rgba(255,69,0,0.3);
            color: var(--fire);
            animation: nightPulse 1.5s ease-in-out infinite;
        }

        @keyframes nightPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255,69,0,0.2); }
            50% { box-shadow: 0 0 30px rgba(255,69,0,0.4); }
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .btn:hover { transform: translateY(-1px); }
        .btn:active { transform: translateY(1px); }

        .btn-primary {
            background: linear-gradient(135deg, var(--fire), var(--fire-glow));
            color: white;
            box-shadow: 0 4px 15px rgba(255,69,0,0.3);
        }

        .btn-primary:hover {
            box-shadow: 0 6px 25px rgba(255,69,0,0.5);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            color: var(--text);
            border: 1px solid #333366;
        }

        .btn-secondary:hover {
            border-color: var(--accent);
        }

        .btn-success {
            background: linear-gradient(135deg, #00aa55, #00cc66);
            color: white;
            box-shadow: 0 4px 15px rgba(0,170,85,0.3);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .settings-row label {
            color: #8888bb;
            font-size: 0.85em;
            min-width: 30px;
        }

        .settings-row input[type="number"] {
            width: 60px;
            padding: 6px 8px;
            background: #1a1a3a;
            border: 1px solid #333366;
            border-radius: 8px;
            color: var(--text);
            font-family: 'Orbitron', monospace;
            font-size: 0.85em;
            text-align: center;
        }

        .settings-row input[type="number"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        .tooltip {
            position: fixed;
            background: #1a1a3a;
            border: 1px solid #444488;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.8em;
            color: var(--text);
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        .tooltip.visible { opacity: 1; }

        .legend {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8em;
            color: #8888bb;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,10,26,0.92);
            padding: 30px 40px;
            border-radius: 16px;
            border: 2px solid var(--fire);
            text-align: center;
            z-index: 10;
            display: none;
            backdrop-filter: blur(10px);
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .message-overlay h2 {
            font-family: 'Orbitron', monospace;
            color: var(--fire);
            margin-bottom: 10px;
        }

        .message-overlay p {
            color: #aaaacc;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .description-card {
            background: var(--bg-card);
            border: 1px solid #222244;
            border-radius: 14px;
            padding: 18px;
            margin-bottom: 20px;
            line-height: 1.6;
            font-size: 0.9em;
            color: #aaaacc;
        }

        .description-card strong {
            color: var(--text);
        }

        .description-card .highlight-fire {
            color: var(--fire);
            font-weight: 600;
        }

        .description-card .highlight-shield {
            color: var(--protected);
            font-weight: 600;
        }

        .remaining-shields {
            text-align: center;
            font-family: 'Orbitron', monospace;
            font-size: 1.4em;
            color: var(--protected);
            padding: 10px;
            background: rgba(0,191,255,0.08);
            border-radius: 10px;
            border: 1px solid rgba(0,191,255,0.2);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-control input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
        }

        #gameCanvas {
            cursor: crosshair;
        }

        .won-overlay h2 {
            color: #00cc66 !important;
        }

        .won-overlay {
            border-color: #00cc66 !important;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <div id="app">
        <h1>THE SECRET GAME</h1>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('a')">
                –†–µ–∂–∏–º A
                <span class="label">–û–¥–∏–Ω –ø–æ–∂–∞—Ä–Ω—ã–π –≤ –¥–µ–Ω—å</span>
            </button>
            <button class="mode-btn" onclick="setMode('b')">
                –†–µ–∂–∏–º B
                <span class="label">–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ m&times;n</span>
            </button>
        </div>

        <div class="game-container">
            <div class="grid-wrapper" id="gridWrapper">
                <canvas id="gameCanvas" width="800" height="800"></canvas>
                <div class="message-overlay" id="messageOverlay">
                    <h2 id="msgTitle">–û–≥–æ–Ω—å –Ω–µ—É–¥–µ—Ä–∂–∏–º!</h2>
                    <p id="msgText">–û–≥–æ–Ω—å –≤—ã—à–µ–ª –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –≤–∏–¥–∏–º–æ–π –æ–±–ª–∞—Å—Ç–∏.</p>
                    <button class="btn btn-primary" onclick="restartGame()">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
                </div>
            </div>

            <div class="sidebar">
                <div class="phase-indicator phase-day" id="phaseIndicator">
                    ‚òÄ –î–ï–ù–¨ 1
                </div>

                <div class="info-card" id="shieldsCard" style="display:none">
                    <h3 id="shieldsCardTitle">–ó–ê–©–ò–¢ –†–ê–°–°–¢–ê–í–õ–ï–ù–û</h3>
                    <div class="remaining-shields" id="remainingShields">0</div>
                </div>

                <div class="info-card">
                    <h3>–°–¢–ê–¢–ò–°–¢–ò–ö–ê</h3>
                    <div class="stat">
                        <span class="stat-label">–î–µ–Ω—å</span>
                        <span class="stat-value day" id="statDay">1</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ö–ª–µ—Ç–æ–∫ –≥–æ—Ä–∏—Ç</span>
                        <span class="stat-value fire" id="statFire">1</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ó–∞—â–∏—â–µ–Ω–æ</span>
                        <span class="stat-value shield" id="statShield">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ó–∞—â–∏—Ç —Å–µ–≥–æ–¥–Ω—è</span>
                        <span class="stat-value shield" id="statToday">0</span>
                    </div>
                </div>

                <div class="info-card" id="modeBSettings" style="display:none">
                    <h3>–ù–ê–°–¢–†–û–ô–ö–ò</h3>
                    <div class="settings-row">
                        <label>m:</label>
                        <input type="number" id="inputM" value="2" min="1" max="10">
                        <label>n:</label>
                        <input type="number" id="inputN" value="2" min="1" max="10">
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-success" id="btnStartGame" onclick="startGame()" style="display:none">
                        ‚ñ∂ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É
                    </button>
                    <button class="btn btn-secondary" onclick="restartGame()">
                        –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ
                    </button>
                </div>

                <div class="info-card">
                    <h3>–£–ü–†–ê–í–õ–ï–ù–ò–ï</h3>
                    <div class="legend-item" style="margin-bottom:6px;font-size:0.85em;color:#8888bb">
                        <strong style="color:var(--text)">–õ–ö–ú</strong> ‚Äî –∑–∞—â–∏—Ç–∏—Ç—å –∫–ª–µ—Ç–∫—É
                    </div>
                    <div class="legend-item" style="margin-bottom:6px;font-size:0.85em;color:#8888bb">
                        <strong style="color:var(--text)">–ü–ö–ú + —Ç—è–Ω—É—Ç—å</strong> ‚Äî –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
                    </div>
                    <div class="legend-item" style="margin-bottom:6px;font-size:0.85em;color:#8888bb">
                        <strong style="color:var(--text)">–ö–æ–ª—ë—Å–∏–∫–æ</strong> ‚Äî –º–∞—Å—à—Ç–∞–±
                    </div>
                    <div class="legend-item" style="font-size:0.85em;color:#8888bb">
                        <strong style="color:var(--text)">R</strong> ‚Äî –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫
                    </div>
                </div>

                <div class="info-card">
                    <h3>–õ–ï–ì–ï–ù–î–ê</h3>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(135deg, #ff4500, #ff8c00);"></div>
                            –û–≥–æ–Ω—å
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(135deg, #00bfff, #00e5ff);"></div>
                            –ó–∞—â–∏—Ç–∞
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #1a1a3a; border: 1px solid #333;"></div>
                            –ü—É—Å—Ç–æ
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const BASE_CELL_SIZE = 28;
    let CELL_SIZE = BASE_CELL_SIZE;
    let zoomLevel = 1;
    const MIN_ZOOM = 0.3;
    const MAX_ZOOM = 3;
    let mode = 'a';
    let day = 1;
    let isDay = true;
    let gameOver = false;
    let transitioning = false;
    let preparationPhase = false;
    let fireCells = new Set();
    let protectedCells = new Set();
    let newFireCells = new Set();
    let shieldsUsedToday = 0;
    let totalShields = 0;
    let maxShieldsToday = 1;
    let initialShieldsCount = 0;
    let animFrame = 0;
    let fireParticles = [];
    let offsetX = 0, offsetY = 0;
    let isDragging = false;
    let dragStartX, dragStartY, dragOffsetX, dragOffsetY;
    let won = false;

    function key(r, c) { return r + ',' + c; }
    function parseKey(k) { const p = k.split(','); return [parseInt(p[0]), parseInt(p[1])]; }

    function createStars() {
        const container = document.getElementById('stars');
        for (let i = 0; i < 100; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            star.style.left = Math.random() * 100 + '%';
            star.style.top = Math.random() * 100 + '%';
            const size = Math.random() * 2 + 1;
            star.style.width = size + 'px';
            star.style.height = size + 'px';
            star.style.setProperty('--dur', (Math.random() * 3 + 2) + 's');
            container.appendChild(star);
        }
    }

    function setMode(m) {
        mode = m;
        document.querySelectorAll('.mode-btn').forEach((b, i) => {
            b.classList.toggle('active', (i === 0 && m === 'a') || (i === 1 && m === 'b'));
        });
        document.getElementById('descA').style.display = m === 'a' ? '' : 'none';
        document.getElementById('descB').style.display = m === 'b' ? '' : 'none';
        document.getElementById('modeBSettings').style.display = m === 'b' ? '' : 'none';
        document.getElementById('shieldsCard').style.display = m === 'b' ? '' : 'none';
        restartGame();
    }

    function restartGame() {
        fireCells = new Set();
        protectedCells = new Set();
        newFireCells = new Set();
        day = 1;
        isDay = true;
        gameOver = false;
        won = false;
        transitioning = false;
        shieldsUsedToday = 0;
        totalShields = 0;
        initialShieldsCount = 0;
        fireParticles = [];
        zoomLevel = 1;
        CELL_SIZE = BASE_CELL_SIZE;
        offsetX = Math.round(canvas.width * 0.08);
        offsetY = Math.round(canvas.height * 0.08);

        if (mode === 'a') {
            fireCells.add(key(0, 0));
            maxShieldsToday = 1;
            preparationPhase = false;
        } else {
            const m = parseInt(document.getElementById('inputM').value) || 2;
            const n = parseInt(document.getElementById('inputN').value) || 2;
            for (let r = 0; r < m; r++) {
                for (let c = 0; c < n; c++) {
                    fireCells.add(key(r, c));
                }
            }
            maxShieldsToday = Infinity;
            preparationPhase = true;
        }

        document.getElementById('messageOverlay').style.display = 'none';
        updateUI();
        draw();
    }

    function updateUI() {
        const phaseEl = document.getElementById('phaseIndicator');
        if (preparationPhase) {
            phaseEl.className = 'phase-indicator phase-day';
            phaseEl.textContent = 'üõ° –ü–û–î–ì–û–¢–û–í–ö–ê';
        } else if (isDay) {
            phaseEl.className = 'phase-indicator phase-day';
            phaseEl.textContent = '‚òÄ –î–ï–ù–¨ ' + day;
        } else {
            phaseEl.className = 'phase-indicator phase-night';
            phaseEl.textContent = 'üåô –ù–û–ß–¨ ' + day;
        }

        document.getElementById('statDay').textContent = preparationPhase ? '‚Äî' : day;
        document.getElementById('statFire').textContent = fireCells.size;
        document.getElementById('statShield').textContent = totalShields;

        if (preparationPhase) {
            document.getElementById('statToday').textContent = shieldsUsedToday + ' / ‚àû';
        } else {
            document.getElementById('statToday').textContent = shieldsUsedToday + ' / ' + maxShieldsToday;
        }

        if (mode === 'b') {
            const titleEl = document.getElementById('shieldsCardTitle');
            const shieldsEl = document.getElementById('remainingShields');
            if (preparationPhase) {
                titleEl.textContent = '–ó–ê–©–ò–¢ –†–ê–°–°–¢–ê–í–õ–ï–ù–û';
                shieldsEl.textContent = shieldsUsedToday;
            } else {
                titleEl.textContent = '–ó–ê–©–ò–¢ –û–°–¢–ê–õ–û–°–¨';
                shieldsEl.textContent = Math.max(0, maxShieldsToday - shieldsUsedToday);
            }
        }

        const btnStart = document.getElementById('btnStartGame');
        btnStart.style.display = (preparationPhase && shieldsUsedToday > 0) ? '' : 'none';
    }

    function canProtect() {
        if (preparationPhase) return !gameOver && !transitioning;
        return isDay && !gameOver && !transitioning && shieldsUsedToday < maxShieldsToday;
    }

    function handleCanvasClick(e) {
        if (gameOver || transitioning) return;
        if (!preparationPhase && !isDay) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mx = (e.clientX - rect.left) * scaleX;
        const my = (e.clientY - rect.top) * scaleY;

        const col = Math.floor((mx - offsetX) / CELL_SIZE);
        const row = Math.floor((my - offsetY) / CELL_SIZE);

        if (row < 0 || col < 0) return;

        const k = key(row, col);

        if (fireCells.has(k) || protectedCells.has(k)) return;
        if (!canProtect()) return;

        protectedCells.add(k);
        shieldsUsedToday++;
        totalShields++;

        createShieldParticle(col, row);
        updateUI();
        draw();

        if (!preparationPhase && shieldsUsedToday >= maxShieldsToday) {
            autoNight();
        }
    }

    function startGame() {
        if (!preparationPhase || shieldsUsedToday === 0) return;
        initialShieldsCount = shieldsUsedToday;
        preparationPhase = false;
        day = 1;
        shieldsUsedToday = 0;
        maxShieldsToday = 1;
        isDay = false;
        updateUI();
        draw();

        setTimeout(() => {
            spreadFire();
            isDay = true;
            transitioning = false;
            checkGameState();
            updateUI();
            draw();
        }, 500);
    }

    function createShieldParticle(col, row) {
        for (let i = 0; i < 6; i++) {
            fireParticles.push({
                x: (col + 0.5) * CELL_SIZE + offsetX,
                y: (row + 0.5) * CELL_SIZE + offsetY,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                life: 1,
                color: 'shield'
            });
        }
    }

    function autoNight() {
        if (!isDay || gameOver || transitioning || preparationPhase) return;
        transitioning = true;
        isDay = false;
        updateUI();
        draw();

        setTimeout(() => {
            spreadFire();
            isDay = true;
            day++;
            shieldsUsedToday = 0;
            maxShieldsToday = 1;
            transitioning = false;

            checkGameState();
            updateUI();
            draw();
        }, 500);
    }

    function endDay() {
        autoNight();
    }

    function spreadFire() {
        const newFire = new Set();
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]];

        for (const k of fireCells) {
            const [r, c] = parseKey(k);
            for (const [dr, dc] of dirs) {
                const nr = r + dr;
                const nc = c + dc;
                if (nr < 0 || nc < 0) continue;
                const nk = key(nr, nc);
                if (!fireCells.has(nk) && !protectedCells.has(nk)) {
                    newFire.add(nk);
                }
            }
        }

        for (const k of newFire) {
            fireCells.add(k);
            const [r, c] = parseKey(k);
            for (let i = 0; i < 4; i++) {
                fireParticles.push({
                    x: (c + 0.5) * CELL_SIZE + offsetX,
                    y: (r + 0.5) * CELL_SIZE + offsetY,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 3,
                    life: 1,
                    color: 'fire'
                });
            }
        }

        newFireCells = newFire;
    }

    function checkGameState() {
        let maxR = 0, maxC = 0;
        for (const k of fireCells) {
            const [r, c] = parseKey(k);
            maxR = Math.max(maxR, r);
            maxC = Math.max(maxC, c);
        }

        if (maxR >= 150 || maxC >= 150) {
            gameOver = true;
            const overlay = document.getElementById('messageOverlay');
            overlay.style.display = 'block';
            overlay.className = 'message-overlay';
            document.getElementById('msgTitle').textContent = '–û–≥–æ–Ω—å –Ω–µ—É–¥–µ—Ä–∂–∏–º!';
            document.getElementById('msgText').textContent =
                mode === 'a'
                    ? '–ö–∞–∫ –∏ —É—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç —Ç–µ–æ—Ä–µ–º–∞ ‚Äî –æ–¥–∏–Ω –ø–æ–∂–∞—Ä–Ω—ã–π –Ω–µ –º–æ–∂–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –æ–≥–æ–Ω—å –≤ —É–≥–ª—É –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π —Ä–µ—à—ë—Ç–∫–∏!'
                    : '–û–≥–æ–Ω—å –≤—ã—Ä–≤–∞–ª—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª—ã! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞—â–∏—Ç.';
            return;
        }

        if (mode === 'b' && day > 2) {
            let contained = true;
            const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
            for (const k of fireCells) {
                const [r, c] = parseKey(k);
                for (const [dr, dc] of dirs) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr < 0 || nc < 0) continue;
                    const nk = key(nr, nc);
                    if (!fireCells.has(nk) && !protectedCells.has(nk)) {
                        contained = false;
                        break;
                    }
                }
                if (!contained) break;
            }

            if (contained) {
                gameOver = true;
                won = true;
                const overlay = document.getElementById('messageOverlay');
                overlay.style.display = 'block';
                overlay.className = 'message-overlay won-overlay';
                document.getElementById('msgTitle').textContent = '–û–≥–æ–Ω—å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!';
                document.getElementById('msgText').textContent =
                    '–í—ã –æ–≥—Ä–∞–Ω–∏—á–∏–ª–∏ –æ–≥–æ–Ω—å –∫–æ–Ω–µ—á–Ω–æ–π –æ–±–ª–∞—Å—Ç—å—é! –ó–∞—â–∏—Ç –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ: ' +
                    initialShieldsCount +
                    ', –≤—Å–µ–≥–æ –∑–∞—â–∏—â–µ–Ω–æ: ' + totalShields + ' –∫–ª–µ—Ç–æ–∫.';
            }
        }
    }

    function draw() {
        const W = canvas.width;
        const H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        ctx.fillStyle = '#0d0d20';
        ctx.fillRect(0, 0, W, H);

        const cs = CELL_SIZE;
        const startCol = Math.max(0, Math.floor(-offsetX / cs));
        const startRow = Math.max(0, Math.floor(-offsetY / cs));
        const endCol = startCol + Math.ceil(W / cs) + 1;
        const endRow = startRow + Math.ceil(H / cs) + 1;

        for (let r = startRow; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
                const px = c * cs + offsetX;
                const py = r * cs + offsetY;

                if (px + cs < 0 || py + cs < 0 || px > W || py > H) continue;

                const k = key(r, c);

                if (fireCells.has(k)) {
                    const flicker = 0.85 + 0.15 * Math.sin(animFrame * 0.1 + r * 0.7 + c * 0.5);
                    const isNew = newFireCells.has(k);
                    const grd = ctx.createRadialGradient(
                        px + cs / 2, py + cs / 2, 0,
                        px + cs / 2, py + cs / 2, cs * 0.7
                    );
                    if (isNew) {
                        grd.addColorStop(0, `rgba(255, 255, 100, ${flicker})`);
                        grd.addColorStop(0.5, `rgba(255, 140, 0, ${flicker})`);
                        grd.addColorStop(1, `rgba(255, 69, 0, ${flicker * 0.8})`);
                    } else {
                        grd.addColorStop(0, `rgba(255, 180, 50, ${flicker})`);
                        grd.addColorStop(0.5, `rgba(255, 100, 0, ${flicker})`);
                        grd.addColorStop(1, `rgba(200, 40, 0, ${flicker * 0.7})`);
                    }
                    ctx.fillStyle = grd;
                    ctx.fillRect(px + 1, py + 1, cs - 2, cs - 2);

                    ctx.shadowColor = 'rgba(255, 100, 0, 0.4)';
                    ctx.shadowBlur = 8;
                    ctx.fillRect(px + 1, py + 1, cs - 2, cs - 2);
                    ctx.shadowBlur = 0;

                } else if (protectedCells.has(k)) {
                    const pulse = 0.7 + 0.3 * Math.sin(animFrame * 0.05 + r + c);
                    const grd = ctx.createRadialGradient(
                        px + cs / 2, py + cs / 2, 0,
                        px + cs / 2, py + cs / 2, cs * 0.6
                    );
                    grd.addColorStop(0, `rgba(0, 229, 255, ${pulse})`);
                    grd.addColorStop(1, `rgba(0, 120, 200, ${pulse * 0.6})`);
                    ctx.fillStyle = grd;
                    ctx.fillRect(px + 1, py + 1, cs - 2, cs - 2);

                    ctx.shadowColor = 'rgba(0, 191, 255, 0.3)';
                    ctx.shadowBlur = 6;
                    ctx.fillRect(px + 1, py + 1, cs - 2, cs - 2);
                    ctx.shadowBlur = 0;

                    if (cs > 14) {
                        ctx.fillStyle = `rgba(255,255,255,${pulse * 0.5})`;
                        ctx.font = `${Math.max(8, cs * 0.4)}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üõ°', px + cs / 2, py + cs / 2);
                    }
                } else {
                    ctx.fillStyle = '#13132a';
                    ctx.fillRect(px + 1, py + 1, cs - 2, cs - 2);
                }
            }
        }

        ctx.strokeStyle = 'rgba(60, 60, 120, 0.25)';
        ctx.lineWidth = 0.5;
        for (let r = startRow; r <= endRow; r++) {
            const py = r * cs + offsetY;
            if (py < 0 || py > H) continue;
            ctx.beginPath();
            ctx.moveTo(Math.max(0, startCol * cs + offsetX), py);
            ctx.lineTo(Math.min(W, (endCol + 1) * cs + offsetX), py);
            ctx.stroke();
        }
        for (let c = startCol; c <= endCol; c++) {
            const px = c * cs + offsetX;
            if (px < 0 || px > W) continue;
            ctx.beginPath();
            ctx.moveTo(px, Math.max(0, startRow * cs + offsetY));
            ctx.lineTo(px, Math.min(H, (endRow + 1) * cs + offsetY));
            ctx.stroke();
        }

        const edgePx = offsetX;
        const edgePy = offsetY;
        if (edgePx > 0) {
            ctx.fillStyle = 'rgba(100, 60, 150, 0.15)';
            ctx.fillRect(0, 0, edgePx, H);
            ctx.strokeStyle = 'rgba(124, 77, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(edgePx, 0);
            ctx.lineTo(edgePx, H);
            ctx.stroke();
        }
        if (edgePy > 0) {
            ctx.fillStyle = 'rgba(100, 60, 150, 0.15)';
            ctx.fillRect(0, 0, W, edgePy);
            ctx.strokeStyle = 'rgba(124, 77, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, edgePy);
            ctx.lineTo(W, edgePy);
            ctx.stroke();
        }

        for (let i = fireParticles.length - 1; i >= 0; i--) {
            const p = fireParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.03;
            if (p.life <= 0) {
                fireParticles.splice(i, 1);
                continue;
            }
            const alpha = p.life * 0.8;
            const radius = p.life * 3;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color === 'fire'
                ? `rgba(255, ${Math.floor(100 + p.life * 155)}, 0, ${alpha})`
                : `rgba(0, ${Math.floor(180 + p.life * 75)}, 255, ${alpha})`;
            ctx.fill();
        }

        animFrame++;
    }

    function animate() {
        draw();
        requestAnimationFrame(animate);
    }

    function resizeCanvas() {
        const wrapper = document.getElementById('gridWrapper');
        const size = Math.min(wrapper.clientWidth - 32, 800);
        const dpr = window.devicePixelRatio > 1 ? 2 : 1;
        canvas.width = size * dpr;
        canvas.height = canvas.width;
        canvas.style.width = size + 'px';
        canvas.style.height = size + 'px';
        CELL_SIZE = Math.round(BASE_CELL_SIZE * zoomLevel * dpr);
    }

    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 2) {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragOffsetX = offsetX;
            dragOffsetY = offsetY;
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
            return;
        }
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const dpr = window.devicePixelRatio > 1 ? 2 : 1;
            const dx = (e.clientX - dragStartX) * dpr;
            const dy = (e.clientY - dragStartY) * dpr;
            offsetX = dragOffsetX + dx;
            offsetY = dragOffsetY + dy;
            const maxPan = canvas.width * 0.15;
            offsetX = Math.min(offsetX, maxPan);
            offsetY = Math.min(offsetY, maxPan);
        }

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mx = (e.clientX - rect.left) * scaleX;
        const my = (e.clientY - rect.top) * scaleY;
        const col = Math.floor((mx - offsetX) / CELL_SIZE);
        const row = Math.floor((my - offsetY) / CELL_SIZE);

        const tooltip = document.getElementById('tooltip');
        if (row >= 0 && col >= 0) {
            const k = key(row, col);
            let status = '–ü—É—Å—Ç–æ';
            if (fireCells.has(k)) status = 'üî• –ì–æ—Ä–∏—Ç';
            else if (protectedCells.has(k)) status = 'üõ° –ó–∞—â–∏—â–µ–Ω–æ';
            tooltip.textContent = `[${row}, ${col}] ‚Äî ${status}`;
            tooltip.style.left = (e.clientX + 12) + 'px';
            tooltip.style.top = (e.clientY + 12) + 'px';
            tooltip.classList.add('visible');
        } else {
            tooltip.classList.remove('visible');
        }
    });

    window.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        }
    });

    canvas.addEventListener('mouseleave', () => {
        document.getElementById('tooltip').classList.remove('visible');
    });

    canvas.addEventListener('click', handleCanvasClick);

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio > 1 ? 2 : 1;
        const mouseX = (e.clientX - rect.left) * dpr;
        const mouseY = (e.clientY - rect.top) * dpr;

        const worldX = (mouseX - offsetX) / CELL_SIZE;
        const worldY = (mouseY - offsetY) / CELL_SIZE;

        const zoomFactor = e.deltaY < 0 ? 1.15 : 0.87;
        zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * zoomFactor));
        CELL_SIZE = Math.round(BASE_CELL_SIZE * zoomLevel * dpr);

        offsetX = mouseX - worldX * CELL_SIZE;
        offsetY = mouseY - worldY * CELL_SIZE;

        const maxPan = canvas.width * 0.15;
        offsetX = Math.min(offsetX, maxPan);
        offsetY = Math.min(offsetY, maxPan);
    }, { passive: false });

    document.getElementById('inputM')?.addEventListener('change', restartGame);
    document.getElementById('inputN')?.addEventListener('change', restartGame);

    document.addEventListener('keydown', (e) => {
        if (e.code === 'KeyR') {
            restartGame();
        }
    });

    window.addEventListener('resize', () => {
        resizeCanvas();
        draw();
    });

    const gridWrapper = document.getElementById('gridWrapper');
    gridWrapper.addEventListener('mousemove', (e) => {
        const rect = gridWrapper.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width * 100).toFixed(1);
        const y = ((e.clientY - rect.top) / rect.height * 100).toFixed(1);
        gridWrapper.style.setProperty('--mx', x + '%');
        gridWrapper.style.setProperty('--my', y + '%');
    });

    createStars();
    resizeCanvas();
    restartGame();
    animate();
    </script>
</body>
</html>
